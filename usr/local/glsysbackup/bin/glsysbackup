#!/usr/bin/env bash

#===================================================================================================
#
#  Author:				Christian Zettel (ccztux)
#						2017-02-04
#						http://linuxinside.at
#
#  Copyright:			Copyright Â© 2017 Christian Zettel (ccztux), all rights reserved
#
#  Project website:		https://github.com/ccztux/glsysbackup
#
#  Last Modification:	Christian Zettel (ccztux)
#						2019-11-17
#
#  Version				2.0.0-beta4
#
#  Description:			Generic Linux System Backup is an advanced backup tool written in bash.
#
#  License:				GNU GPLv3
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#===================================================================================================


#--------------------------------
# Print error messages to stderr:
#--------------------------------

eprintf()
{
	printf "%b\\n" "${1}" >&2
}



#-------
# Traps:
#-------

if ! trap 'signalHandler SIGTERM' SIGTERM
then
	eprintf "Setting trap for signal: 'SIGTERM' was not successful."
	eprintf "Terminating..."
	exit 247
fi

if ! trap 'signalHandler SIGINT' SIGINT
then
	eprintf "Setting trap for signal: 'SIGINT' was not successful."
	eprintf "Terminating..."
	exit 247
fi

if ! trap 'signalHandler SIGHUP' SIGHUP
then
	eprintf "Setting trap for signal: 'SIGHUP' was not successful."
	eprintf "Terminating..."
	exit 247
fi

if ! trap 'signalHandler SIGABRT' SIGABRT
then
	eprintf "Setting trap for signal: 'SIGABRT' was not successful."
	eprintf "Terminating..."
	exit 247
fi

if ! trap 'signalHandler SIGQUIT' SIGQUIT
then
	eprintf "Setting trap for signal: 'SIGQUIT' was not successful."
	eprintf "Terminating..."
	exit 247
fi

if ! trap 'signalHandler "ERR" "${BASH_SOURCE[${#BASH_SOURCE[@]} - 1]}" "${LINENO}" "${BASH_COMMAND}"' ERR
then
	eprintf "Setting trap for signal: 'ERR' was not successful."
	eprintf "Terminating..."
	exit 247
fi

if ! trap 'signalHandler "EXIT"' EXIT
then
	eprintf "Setting trap for signal: 'EXIT' was not successful."
	eprintf "Terminating..."
	exit 247
fi



#---------------
# signalHandler:
#---------------

signalHandler()
{
	local signal="${1:-}"
	local bash_source="${2:-}"
	local lineno="${3:-}"
	local bash_command="${4:-}"

	case "${signal}" in
		SIGTERM)
			if [ "${script_shutdown_in_progress}" -ne "1" ]
			then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="143"
			exit
			;;
		SIGINT)
			if [ "${script_shutdown_in_progress}" -ne "1" ]
			then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="130"
			exit
			;;
		SIGHUP)
			if [ "${script_shutdown_in_progress}" -ne "1" ]
			then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="129"
			exit
			;;
		SIGABRT)
			if [ "${script_shutdown_in_progress}" -ne "1" ]
			then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="134"
			exit
			;;
		SIGQUIT)
			if [ "${script_shutdown_in_progress}" -ne "1" ]
			then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="129"
			exit
			;;
		ERR)
			if [ "${script_shutdown_in_progress}" -ne "1" ]
			then
				logHandler "Caught: '${signal}', in: '${bash_source}' at line number: '${lineno}', command: '${bash_command}'."
			fi

			script_exit_code="1"
			exit
			;;
		EXIT)
			if [ "${script_config_file_included}" -eq "1" ]
			then
				logHandler "Caught: '${signal}', exiting script..."

				if [ "${script_bypass_exit_routines}" -ne "1" ]
				then
					cleanUp

					if { [ "${backup_encryption_enabled:-}" -eq "1" ] && [ "${encryption_successful:-}" -eq "1" ]; } || { [ "${backup_encryption_enabled:-}" -eq "0" ] && [ "${backup_successful:-}" -eq "1" ]; }
					then
						script_exit_code="0"
						rotateHandler
					else
						logHandler "The backup job was not successful, so we dont rotate backup files."
					fi

					if [ "${script_another_instance_is_running}" -ne "1" ]
					then
						if checkLock
						then
							removeLock
						fi
					fi
				fi

				if [ "${script_exit_code}" -eq "0" ]
				then
					logHandler "We did a great job. :)"
				else
					logHandler "Ooops!!! Something went wrong. :("
					logHandler "Read the log or output to determine what exactly went wrong."
				fi

				logHandler "${script_name} (${script_version}) was running: '${SECONDS}' seconds, script_exit_code: '${script_exit_code}'."
				logHandler "Bye, bye..."
			fi

			${kill_bin:=kill} -s "${signal}" -- -"${script_pid}" 2>/dev/null

			exit ${script_exit_code}
			;;
		*)
			logHandler "Caught: '${signal}' in function: '${FUNCNAME[0]}', but dont know what to do with it..."
			return 1
			;;
	esac
}



#------------------------
# Bash and shell options:
#------------------------

checkShellOption()
{
	local shell_option="${1}"

	if [ -n "${shell_option}" ]
	then
		if [[ "${-}" =~ ^(.*)${shell_option}(.*)$ ]] || [[ "${SHELLOPTS}" =~ ^(.*)${shell_option}(.*)$ ]]
		then
			return 0
		else
			return 1
		fi
	else
		return 2
	fi
}

setShellOption()
{
	local shell_option="${1}"

	if [ -n "${shell_option}" ]
	then
		if [[ "${shell_option}" =~ ^([A-Z]|[a-z])$ ]]
		then
			if set -"${shell_option}" 2>/dev/null
			then
				return 0
			else
				return 1
			fi
		else
			if set -o "${shell_option}" 2>/dev/null
			then
				return 0
			else
				return 1
			fi
		fi
	else
		return 2
	fi
}

checkBashOption()
{
	local bash_option="${1}"

	if [ -n "${bash_option}" ]
	then
		if shopt -q "${bash_option}" 2>/dev/null
		then
			return 0
		else
			return 1
		fi
	else
		return 2
	fi
}

setBashOption()
{
	local bash_option="${1}"

	if [ -n "${bash_option}" ]
	then
		if shopt -s "${bash_option}" 2>/dev/null
		then
			return 0
		else
			return 1
		fi
	else
		return 2
	fi
}

setRequiredShellOptions()
{
	local shell_option=
	local required_shell_options=("noclobber" "nounset" "pipefail")

	for shell_option in "${required_shell_options[@]}"
	do
		if ! checkShellOption "${shell_option}"
		then
			if ! setShellOption "${shell_option}"
			then
				eprintf "Setting required shell option: '${shell_option}' was not successful."
				eprintf "Terminating..."
				exit 245
			fi
		fi
	done
}

setRequiredBashOptions()
{
	local bash_option=
	local required_bash_options=("nullglob")

	for bash_option in "${required_bash_options[@]}"
	do
		if ! checkBashOption "${bash_option}"
		then
			if ! setBashOption "${bash_option}"
			then
				eprintf "Setting required bash option: '${bash_option}' was not successful."
				eprintf "Terminating..."
				exit 246
			fi
		fi
	done
}



#-------------------
# Various Functions:
#-------------------

printUsage()
{
	setRequiredVariables

	printf "Usage: %s OPTIONS\\n\\n" "${script_name}"
	printf "Author:\\t\\t\\t%s\\n" "${script_author}"
	printf "Last modification:\\t%s\\n" "${script_last_modification_date}"
	printf "Version:\\t\\t%s\\n\\n" "${script_version}"
	printf "Description:\\t\\t%s\\n\\n" "${script_description}"
	printf "OPTIONS:\\n"
	printf "   -c\\t\\tPath to config file. Example: '%s/etc/%s.conf'. (The file extension has to be: '.conf')\\n" "${script_base_path}" "${script_name}"
	printf "   -h\\t\\tShows this help.\\n"
	printf "   -v\\t\\tShows detailed version information.\\n"
}

printScriptInfos()
{
	printf "Author:\\t\\t\\t%s\\n" "${script_author}"
	printf "Project website:\\t%s\\n" "${script_project_website}"
	printf "License:\\t\\t%s\\n\\n" "${script_license}"
	printf "Last modification:\\t%s\\n" "${script_last_modification_date}"
	printf "Version:\\t\\t%s\\n\\n" "${script_version}"
	printf "Description:\\t\\t%s\\n\\n" "${script_description}"
	printf "Copyright:\\t\\t%s\\n" "${script_copyright}"
}

checkBin()
{
	local binary="${1:-}"
	local _bin=

	if _bin="$(command -v "${binary}" 2>/dev/null)"
	then
		export "${binary//-/_}"_bin="${_bin}"
		return 0
	else
		return 1
	fi
}

checkRequiredBinaries()
{
	local bin=
	local syspackman=
	local required_binaries=()
	local binaries_not_found=()
	local binaries_not_found_helper=
	local supported_syspackage_managers=("rpm" "dpkg" "pacman" "equery" "pkgutil")

	if [ "${log_to_syslog}" -eq "1" ]
	then
		required_binaries+=("logger")
	fi

	if [ "${log_to_journal}" -eq "1" ]
	then
		required_binaries+=("systemd-cat")
	fi

	if [ "${log_to_file}" -eq "1" ] || [ "${log_to_stdout}" -eq "1" ]
	then
		if [ "${BASH_VERSINFO[0]}" -ge "4" ] && [ "${BASH_VERSINFO[1]}" -ge "2" ]
		then
			date_bin_printf="1"
			date_bin="printf"
		else
			date_bin_printf="0"
			required_binaries+=("date")
		fi
	fi

	if [ "${backup_rotation_daily_enabled}" -eq "1" ] || [ "${backup_rotation_weekly_enabled}" -eq "1" ] || [ "${backup_rotation_monthly_enabled}" -eq "1" ]
	then
		required_binaries+=("cp")
	fi

	if [ "${backup_encryption_enabled}" -eq "1" ]
	then
		required_binaries+=("openssl")
	fi

	if [ "${re_nice_enabled}" -eq "1" ]
	then
		required_binaries+=("renice")
	fi

	if [ "${re_ionice_enabled}" -eq "1" ]
	then
		required_binaries+=("ionice")
	fi

	required_binaries+=("whoami" "pgrep" "rm" "tar" "mkdir" "kill")

	for bin in "${required_binaries[@]}"
	do
		if ! checkBin "${bin}"
		then
			binaries_not_found+=("${bin}")
		fi
	done

	if [ "${#binaries_not_found[@]}" -gt "1" ]
	then
		binaries_not_found_helper="${binaries_not_found[*]}"
		binaries_not_found_helper="${binaries_not_found_helper//\ /\,\ }"

		logHandler "Required binaries: '${binaries_not_found_helper}' not found, exiting."
		script_exit_code="127"
		exit
	elif [ "${#binaries_not_found[@]}" -eq "1" ]
	then
		logHandler "Required binary: '${binaries_not_found[*]}' not found, exiting."
		script_exit_code="127"
		exit
	fi

	if [ "${installed_packages_enabled}" -eq "1" ]
	then
		available_syspackage_managers=()

		if [ -z "${installed_packages_forced_manager}" ]
		then
			for syspackman in "${supported_syspackage_managers[@]}"
			do
				if checkBin "${syspackman}"
				then
					available_syspackage_managers+=("${syspackman}")
				fi
			done
		else
			if checkBin "${installed_packages_forced_manager}"
			then
				available_syspackage_managers+=("${installed_packages_forced_manager}")
			fi
		fi
	fi
}

includeConfig()
{
	checkFileParameters "${script_config_file}"

	if [ "$(( file_permission & b_regular_file_exists ))" -gt "0" ] && [ "$(( file_permission & b_regular_file_is_not_empty ))" -gt "0" ] && [ "$(( file_permission & b_permission_read ))" -gt "0" ]
	then
		# shellcheck source=/scripts/usr/local/glsysbackup/etc/glsysbackup.conf
		if source "${script_config_file}"
		then
			script_config_file_included="1"
		else
			logHandler "Including config file: '${script_config_file}' was not successful."
			logHandler "Terminating..."

			script_bypass_exit_routines="1"
			script_exit_code="20"
			exit
		fi
	elif [ "$(( file_permission & b_regular_file_exists ))" -eq "0" ]
	then
		logHandler "Config file: '${script_config_file}' does not exist."
		logHandler "Terminating..."

		script_bypass_exit_routines="1"
		script_exit_code="21"
		exit
	elif [ "$(( file_permission & b_regular_file_is_not_empty ))" -eq "0" ]
	then
		logHandler "Config file: '${script_config_file}' exists, but is empty."
		logHandler "Terminating..."

		script_bypass_exit_routines="1"
		script_exit_code="22"
		exit
	elif [ "$(( file_permission & b_permission_read ))" -eq "0" ]
	then
		logHandler "Config file: '${script_config_file}' exists, but it is not readable."
		logHandler "Terminating..."

		script_bypass_exit_routines="1"
		script_exit_code="23"
		exit
	fi
}

calculateFunctionNameLength()
{
	local function=
	local function_names=()
	function_names_max_length="0"
	IFS=$'\n' read -d "" -r -a function_names <<< "$(declare -F)"

	for function in "${function_names[@]//declare -f /}"
	do
		if [ "${#function}" -gt "${function_names_max_length}" ]
		then
			function_names_max_length="${#function}"
		fi
	done
}

logHandlerSetConfig()
{
	log_conf="0"
	b_log_to_file="1"
	b_log_to_stdout="2"
	b_log_to_syslog="4"
	b_log_to_journal="8"
	b_date_bin_available="16"
	b_logger_bin_available="32"
	b_systemd_cat_bin_available="64"
	b_log_to_file_truncate="128"

	if [ "${date_bin_printf:-}" -eq "1" ]
	then
		date_cmd_format_prefix="'%("
		date_cmd_format_suffix=")T\\n' -1"
	else
		date_cmd_format_prefix="'+"
		date_cmd_format_suffix="'"
	fi

	if [ "${log_to_file}" -eq "1" ]
	then
		log_conf="$(( log_conf | b_log_to_file ))"
	fi

	if [ "${log_to_stdout}" -eq "1" ]
	then
		log_conf="$(( log_conf | b_log_to_stdout ))"
	fi

	if [ "${log_to_syslog}" -eq "1" ]
	then
		log_conf="$(( log_conf | b_log_to_syslog ))"
	fi

	if [ "${log_to_journal}" -eq "1" ]
	then
		log_conf="$(( log_conf | b_log_to_journal ))"
	fi

	if [ -n "${date_bin:-}" ]
	then
		log_conf="$(( log_conf | b_date_bin_available ))"
	fi

	if [ -n "${logger_bin:-}" ]
	then
		log_conf="$(( log_conf | b_logger_bin_available ))"
	fi

	if [ -n "${systemd_cat_bin:-}" ]
	then
		log_conf="$(( log_conf | b_systemd_cat_bin_available ))"
	fi

	if [ "${log_to_file_truncate}" -eq "1" ]
	then
		log_conf="$(( log_conf | b_log_to_file_truncate ))"
	fi
}

checkLogHandlerRequirements()
{
	if [ "$(( log_conf & b_log_to_stdout ))" -gt "0" ] || [ "$(( log_conf & b_log_to_file ))" -gt "0" ]
	then
		calculateFunctionNameLength
	fi

	if [ "$(( log_conf & b_log_to_file ))" -gt "0" ]
	then
		checkLogDir
	fi

	logHandler "${script_name} ${script_version} starting... (PID=${script_pid})"
	logHandler "We are using config file: '${script_config_file}'."
}

logHandlerStdinHelper()
{
	while read -r
	do
		logHandler "${REPLY}"
	done
}

logHandler()
{
	local log_message="${1:-}"
	local log_timestamp=
	local calling_function=

	if [ -z "${log_message:-}" ]
	then
		if [ ! -t "0" ]
		then
			logHandlerStdinHelper
		fi
	else
		log_message="${log_message//\`/}"

		if [ "${script_log_requirements_ok}" -ne "1" ]
		then
			eprintf "${log_message}"
			return
		fi

		if [ "${FUNCNAME[1]}" != "logHandlerStdinHelper" ]
		then
			calling_function="${FUNCNAME[1]}"
		else
			calling_function="${FUNCNAME[3]}"
		fi

		if [ "$(( log_conf & b_log_to_stdout ))" -gt "0" ]
		then
			if [ "$(( log_conf & b_date_bin_available ))" -gt "0" ]
			then
				if [ -z "${log_timestamp}" ]
				then
					log_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${log_timestamp_format}${date_cmd_format_suffix}")"
				fi

				printf "%s | %6d | %*s | %s\\n" "${log_timestamp}" "${script_pid}" "${function_names_max_length}" "${calling_function}" "${log_message}"
			else
				printf "[Date bin not found] | %6d | %*s | %s\\n" "${script_pid}" "${function_names_max_length}" "${calling_function}" "${log_message}"
			fi
		fi

		if [ "$(( log_conf & b_log_to_file ))" -gt "0" ]
		then
			if [ "$(( log_conf & b_log_to_file_truncate ))" -gt "0" ] && [ "${script_log_file_truncated}" -ne "1" ]
			then
				if true >|"${script_log_file}"
				then
					script_log_file_truncated="1"
				fi
			fi

			if [ "$(( log_conf & b_date_bin_available ))" -gt "0" ]
			then
				if [ -z "${log_timestamp}" ]
				then
					log_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${log_timestamp_format}${date_cmd_format_suffix}")"
				fi

				printf "%s | %6d | %*s | %s\\n" "${log_timestamp}" "${script_pid}" "${function_names_max_length}" "${calling_function}" "${log_message}" >>"${script_log_file}"
			else
				printf "[Date bin not found] | %6d | %*s | %s\\n" "${script_pid}" "${function_names_max_length}" "${calling_function}" "${log_message}" >>"${script_log_file}"
			fi
		fi

		if [ "$(( log_conf & b_log_to_syslog ))" -gt "0" ]
		then
			if [ "$(( log_conf & b_logger_bin_available ))" -gt "0" ]
			then
				${logger_bin} -t "${script_name}[${script_pid}]" "(${calling_function}) ${log_message}"
			fi
		fi

		if [ "$(( log_conf & b_log_to_journal ))" -gt "0" ]
		then
			if [ "$(( log_conf & b_systemd_cat_bin_available ))" -gt "0" ]
			then
				printf "(%s) %s\\n" "${calling_function}" "${log_message}" | ${systemd_cat_bin} --identifier="${script_name}"
			fi
		fi
	fi
}

checkLock()
{
	logHandler "Check if lock file: '${script_lock_file}' exists and if it is read and writeable..."

	checkFileParameters "${script_lock_file}"

	if [ "$(( file_permission & b_regular_file_exists ))" -gt "0" ] && [ "$(( file_permission & b_permission_read ))" -gt "0" ] && [ "$(( file_permission & b_permission_write ))" -gt "0" ]
	then
		logHandler "Lock file exists and it is read/writeable."
		return 0
	elif [ "$(( file_permission & b_regular_file_exists ))" -eq "0" ]
	then
		logHandler "Lock file doesnt exist."
		return 1
	else
		logHandler "Lock file exists, but it is not read/writeable."
		return 2
	fi
}

setLock()
{
	logHandler "Check if script lock directory: '${script_lock_directory}' exists and permissions to set lock are ok..."

	checkFileParameters "${script_lock_directory}"

	if [ "$(( file_permission & b_is_directory ))" -gt "0" ] && [ "$(( file_permission & b_permission_read ))" -gt "0" ] && [ "$(( file_permission & b_permission_execute ))" -gt "0" ]
	then
		logHandler "Script lock directory exists and permissions are ok."
	elif [ "$(( file_permission & b_is_directory ))" -eq "0" ]
	then
		logHandler "Script lock directory doesnt exist."
		logHandler "Creating script lock directory..."

		# shellcheck disable=SC2154
		if ${mkdir_bin} -p "${script_lock_directory}" 2>&1 | logHandler
		then
			logHandler "Creating script lock directory was successful."
		else
			logHandler "Creating script lock directory was not successful."
			script_exit_code="30"
			exit
		fi
	else
		logHandler "Script lock directory exists but permissions are not ok, exiting."
		script_exit_code="31"
		exit
	fi

	logHandler "Setting lock..."

	if printf "%d" "${script_pid}" >"${script_lock_file}"
	then
		logHandler "Setting lock was successful."
	else
		logHandler "Setting lock was not successful. Maybe another instance has set the lock between checking lock and setting lock."
		script_exit_code="32"
		exit
	fi
}

removeLock()
{
	logHandler "Removing lock..."

	# shellcheck disable=SC2154
	if ${rm_bin} "${script_lock_file}" 2>&1 | logHandler
	then
		logHandler "Removing lock was successful."
	else
		logHandler "Removing lock was not successful."
		script_exit_code="40"
		exit
	fi
}

removeLeftoverLock()
{
	logHandler "Removing leftover lock..."

	removeLock
	setLock
}

cleanUp()
{
	logHandler "Now we are doing some cleanup jobs..."

	removeInstalledPackagesFile
	removeOldLeftoverLatestBackups
}

removeInstalledPackagesFile()
{
	if [ "${installed_packages_enabled:-}" -eq "1" ]
	then
		logHandler "Installed packages functionality is enabled, now we check if the file exists, if it is writeable and delete it..."
		logHandler "Check if installed packages file: '${installed_packages_filename}' exists and if it is writeable..."

		checkFileParameters "${installed_packages_filename}"

		if [ "$(( file_permission & b_regular_file_exists ))" -gt "0" ] && [ "$(( file_permission & b_permission_write ))" -gt "0" ]
		then
			logHandler "Installed packages file exists and is writeable."
			logHandler "Deleting installed packages file..."

			# shellcheck disable=SC2154
			if ${rm_bin} "${installed_packages_filename}" 2>&1 | logHandler
			then
				logHandler "Deleting installed packages file was successful."
			else
				logHandler "Deleting installed packages file was not successful."
				script_exit_code="50"
			fi
		elif [ "$(( file_permission & b_regular_file_exists ))" -eq "0" ]
		then
			logHandler "Installed packages file doesnt exist, nothing to do."
		else
			logHandler "Installed packages file exists, but it is not writeable, we can not delete it."
			script_exit_code="51"
		fi
	fi
}

removeOldLeftoverLatestBackups()
{
	logHandler "Checking for old, leftover backups in latest folder..."

	if [ "${backup_encryption_enabled}" -eq "0" ]
	then
		logHandler "Backup encryption is not enabled, now we check if an lefover encrypted backup file exists, if it is writeable and delete it..."
		logHandler "Check if encrypted backup file: '${backup_encryption_filename}' exists and if it is writeable..."

		checkFileParameters "${backup_encryption_filename}"

		if [ "$(( file_permission & b_regular_file_exists ))" -gt "0" ] && [ "$(( file_permission & b_permission_write ))" -gt "0" ]
		then
			logHandler "Old, leftover encrypted backup found in latest folder: '${backup_encryption_filename}' and we have write permission, so we delete it."

			# shellcheck disable=SC2154
			if ${rm_bin} "${backup_encryption_filename}" 2>&1 | logHandler
			then
				logHandler "Deleting file was successful."
			else
				logHandler "Deleting file was not successful."
				script_exit_code="60"
				exit
			fi
		elif [ "$(( file_permission & b_regular_file_exists ))" -eq "0" ]
		then
			logHandler "No old, leftover encrypted backup found in latest folder."
		else
			logHandler "Old, leftover encrypted backup found in latest folder: '${backup_encryption_filename}', but we dont have write permissions, nothing to do."
		fi
	else
		logHandler "Backup encryption is enabled, now we check if an lefover unencrypted backup file exists, if it is writeable and delete it..."
		logHandler "Check if unencrypted backup file: '${backup_filename}' exists and if it is writeable..."

		checkFileParameters "${backup_filename}"

		if [ "$(( file_permission & b_regular_file_exists ))" -gt "0" ] && [ "$(( file_permission & b_permission_write ))" -gt "0" ]
		then
			logHandler "Old, leftover unencrypted backup found in latest folder: '${backup_filename}' and we have write permission, so we delete it."

			# shellcheck disable=SC2154
			if ${rm_bin} "${backup_filename}" 2>&1 | logHandler
			then
				logHandler "Deleting file was successful."
			else
				logHandler "Deleting file was not successful."
				script_exit_code="61"
				exit
			fi
		elif [ "$(( file_permission & b_regular_file_exists ))" -eq "0" ]
		then
			logHandler "No old, leftover unencrypted backup found in latest folder."
		else
			logHandler "Old, leftover unencrypted backup found in latest folder: '${backup_filename}', but we dont have write permissions, nothing to do."
		fi
	fi
}

checkFileParameters()
{
	local file="${1:-}"

	file_permission="0"
	b_permission_execute="1"
	b_permission_write="2"
	b_permission_read="4"
	b_regular_file_exists="8"
	b_regular_file_is_not_empty="16"
	b_is_directory="32"

	if [ -x "${file}" ]
	then
		file_permission="$(( file_permission | b_permission_execute ))"
	fi

	if [ -w "${file}" ]
	then
		file_permission="$(( file_permission | b_permission_write ))"
	fi

	if [ -r "${file}" ]
	then
		file_permission="$(( file_permission | b_permission_read ))"
	fi

	if [ -f "${file}" ]
	then
		file_permission="$(( file_permission | b_regular_file_exists ))"

		if [ -s "${file}" ]
		then
			file_permission="$(( file_permission | b_regular_file_is_not_empty ))"
		fi
	else
		if [ -d "${file}" ]
		then
			file_permission="$(( file_permission | b_is_directory ))"
		fi
	fi
}

setDefaultConfig()
{
	log_to_file="1"
	log_to_stdout="1"
	log_to_syslog="0"
	log_timestamp_format="%Y-%m-%d %H:%M:%S"
	log_to_file_truncate="0"
	root_privileges_required="1"
	re_nice_enabled="0"
	re_nice_priority="19"
	re_ionice_enabled="0"
	re_ionice_scheduling_class="2"
	re_ionice_priority="7"
	backup_rotation_one_backup_per_day_only="1"
	backup_rotation_daily_enabled="1"
	backup_rotation_daily_max_backups="10"
	backup_rotation_weekly_enabled="1"
	backup_rotation_weekly_weekday="1"
	backup_rotation_weekly_max_backups="8"
	backup_rotation_monthly_enabled="1"
	backup_rotation_monthly_day_of_month="1"
	backup_rotation_monthly_max_backups="6"
	installed_packages_enabled="1"
	installed_packages_forced_manager=""
	installed_packages_directory="/root"
	backup_successful_tar_rc="1"
	backup_compression_enabled="1"
	backup_compression_type="gzip"
	backup_verbose_mode_enabled="1"
	backup_show_totals="1"
	backup_individual_options=("")
	backup_destination_path="/var/backups"
	backup_base_filename="my_backup"
	backup_items=("")
	backup_exlude_items=("")
	backup_encryption_enabled="0"
	backup_encryption_password="test1234"
	pre_backup_script_enabled="0"
	pre_backup_script="/home/pi/pre.sh"
	pre_backup_exit_when_unsuccessful="1"
	post_backup_script_enabled="0"
	post_backup_script="/home/pi/post.sh"
	post_backup_exit_when_unsuccessful="1"
}

setRequiredVariables()
{
	script_base_path="/usr/local/${script_name}"
	script_bin_directory="${script_base_path}/bin"
	script_lock_directory="${script_base_path}/var/lock"
	script_log_directory="${script_base_path}/var/log"

	if [ -n "${script_config_file:-}" ]
	then
		script_config_name="${script_config_file##*/}"
		script_config_name="${script_config_name//.conf/}"
		script_lock_file="${script_lock_directory}/${script_name}.${script_config_name}.lock"
		script_log_file="${script_log_directory}/${script_name}.${script_config_name}.log"
		installed_packages_filename="${installed_packages_directory}/${script_name}.${script_config_name}.installed_packges.txt"
	fi
}

setConfigurationVariables()
{
	if [ "${backup_compression_enabled}" -eq "1" ]
	then
		case "${backup_compression_type}" in
			gzip)
				backup_file_extension="tar.gz"
				;;
			bzip2)
				backup_file_extension="tar.bz"
				;;
			xz)
				backup_file_extension="tar.xz"
				;;
			lzip)
				backup_file_extension="tar.lz"
				;;
			lzma)
				backup_file_extension="tar.lzma"
				;;
			lzop)
				backup_file_extension="tar.lzop"
				;;
			*)
				;;
		esac
	fi

	backup_base_directory="${backup_destination_path}/${HOSTNAME}/${script_config_name}"
	backup_filename="${backup_base_directory}/latest/${backup_base_filename}.${backup_file_extension}"
	backup_encryption_file_extension="aes.${backup_file_extension}"
	backup_encryption_filename="${backup_filename//${backup_file_extension}/${backup_encryption_file_extension}}"

	rotation_type=
	rotation_timestamp_base_format="%Y-%m-%d"

	if [ "${backup_encryption_enabled}" -eq "1" ]
	then
		file_extension="${backup_encryption_file_extension}"
	else
		file_extension="${backup_file_extension}"
	fi

	encryption_successful="0"
	backup_successful="0"
}

checkCliOptions()
{
	if [ -n "${script_config_file:-}" ]
	then
		if [[ ! "${script_config_file}" =~ ^(.*).conf$ ]]
		then
			logHandler "Unsupported file extension of config file: '${script_config_file}', exiting.\\n"
			printUsage

			script_bypass_exit_routines="1"
			script_exit_code="70"
			exit
		fi
	else
		logHandler "Mandatory argument: '-c' (config file) missing, exiting.\\n"
		printUsage

		script_bypass_exit_routines="1"
		script_exit_code="71"
		exit
	fi
}

checkRootPrivileges()
{
	logHandler "Check if root priviliges are required..."

	if [ "${root_privileges_required}" -eq "1" ]
	then
		logHandler "Root privileges are required, checking privileges..."

		if [ "${UID}" -eq "0" ]
		then
			logHandler "HOORAY, we have root privileges. :)"
		else
			logHandler "You must run this script as root, terminating."
			script_exit_code="80"
			exit
		fi
	else
		logHandler "Root privileges are not required..."
	fi
}

getUser()
{
	local script_exec_user=

	logHandler "Get user which starts the script..."

	if [ -n "${SUDO_USER:-}" ]
	then
		script_exec_user="${SUDO_USER}"
	else
		# shellcheck disable=SC2154
		script_exec_user="$(${whoami_bin})"
	fi

	logHandler "${script_name} was started by user: '${script_exec_user}'."
}

checkBashVersion()
{
	logHandler "Checking bash version..."

	if [ -z "${BASH_VERSINFO[0]}" ]
	then
		logHandler "Could not determine bash version, exiting."
		script_exit_code="90"
		exit
	else
		if [ "${BASH_VERSINFO[0]}" -lt "${script_minimal_required_bash_version}" ]
		then
			logHandler "Bash version: '${BASH_VERSINFO[0]}' doesnt meet requirements, terminating."

			script_bypass_exit_routines="1"
			script_exit_code="91"
			exit
		else
			logHandler "Bash version: '${BASH_VERSINFO[0]}' meets requirements."
		fi
	fi
}

checkAlreadyRunningInstance()
{
	local pid=
	local running_script_pids=()

	# shellcheck disable=SC2154
	IFS=" " read -r -a running_script_pids <<< "$(${pgrep_bin} -d " " -f "^bash(.*)${script_bin_directory}/${script_name}(.*)${script_config_file}(.*)$")"

	for pid in "${!running_script_pids[@]}"
	do
		if [ "${running_script_pids[${pid}]}" == "${script_pid}" ]
		then
			unset "running_script_pids[${pid}]"
		fi
	done

	logHandler "Check if another instance of: '${script_name}' is already running..."

	if checkLock
	then
		if [ "${#running_script_pids[@]}" -eq "0" ]
		then
			logHandler "Old, leftover lockfile: '${script_lock_file}', but no running processes detected. Maybe ${script_name} was terminated abnormally."
			removeLeftoverLock
		else
			logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' and the following, running processes: '${running_script_pids[*]}' detected)."

			script_another_instance_is_running="1"
			script_bypass_exit_routines="1"
			script_exit_code="100"
			exit
		fi
	else
		if [ "${#running_script_pids[@]}" -eq "0" ]
		then
			logHandler "No other instance of: '${script_name}' is currently running (Neither lockfile: '${script_lock_file}' nor running processes detected)."
			setLock
		else
			logHandler "No other instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist, but the following, running processes: '${running_script_pids[*]}' detected)."
			setLock
		fi
	fi
}

reNice()
{
	logHandler "Check if re-niceing is enabled..."

	if [ "${re_nice_enabled}" -eq "1" ]
	then
		logHandler "Re-niceing is enabled."
		logHandler "Check if renice priority is in range..."

		if [ "${re_nice_priority}" -lt "-20" ] || [ "${re_nice_priority}" -gt "19" ]
		then
			logHandler "Re-nice priority: '${re_nice_priority}' is out of range."
			logHandler "HINT: Have a look at: 'man renice'."

			script_exit_code="110"
			exit
		else
			logHandler "Re-nice priority: '${re_nice_priority}' is in range."
			logHandler "Re-niceing..."

			# shellcheck disable=SC2154
			if ${renice_bin} -n ${re_nice_priority} -p "${script_pid}" 2>&1 | logHandler
			then
				logHandler "Re-niceing was successful."
			else
				logHandler "Re-niceing was not successful."
				script_exit_code="111"
				exit
			fi
		fi
	else
		logHandler "Re-niceing is not enabled."
	fi
}

reIONice()
{
	local re_ionice_cmd=
	local re_ionice_priority_required=

	logHandler "Check if re-ioniceing is enabled..."

	if [ "${re_ionice_enabled}" -eq "1" ]
	then
		logHandler "Re-ioniceing is enabled."
		logHandler "Check if re-ioniceing parameters are in range..."

		if [ "${re_ionice_scheduling_class}" -gt "3" ] || [ "${re_ionice_scheduling_class}" -lt "1" ]
		then
			logHandler "Re-ioniceing scheduling class: '${re_ionice_scheduling_class}' is out of range."
			logHandler "HINT: Have a look at: 'man ionice'."

			script_exit_code="120"
			exit
		else
			logHandler "Re-ioniceing scheduling class: '${re_ionice_scheduling_class}' is in range."
		fi

		if [ "${re_ionice_scheduling_class}" -eq "1" ] || [ "${re_ionice_scheduling_class}" -eq "2" ]
		then
			logHandler "Selected re-ioniceing scheduling class: '${re_ionice_scheduling_class}' requires re-ioniceing priority."
			logHandler "Check if re-ioniceing priority is in range..."

			re_ionice_priority_required="1"

			if [ "${re_ionice_priority}" -gt "7" ] || [ "${re_ionice_priority}" -lt "0" ]
			then
				logHandler "Re-ioniceing priority: '${re_ionice_priority}' is out of range."
				logHandler "HINT: Have a look at: 'man ionice'."

				script_exit_code="121"
				exit
			else
				logHandler "Re-ioniceing priority: '${re_ionice_scheduling_class}' is in range."
			fi
		else
			logHandler "Selected re-ioniceing scheduling class: '${re_ionice_scheduling_class}' does not require a re-ioniceing priority."
		fi

		logHandler "Re-ioniceing..."

		if [ "${re_ionice_priority_required}" -eq "1" ]
		then
			# shellcheck disable=SC2154
			re_ionice_cmd="${ionice_bin} -c ${re_ionice_scheduling_class} -n ${re_ionice_priority} -p ${script_pid}"
		else
			# shellcheck disable=SC2154
			re_ionice_cmd="${ionice_bin} -c ${re_ionice_scheduling_class} -p ${script_pid}"
		fi

		if ${re_ionice_cmd} 2>&1 | logHandler
		then
			logHandler "Re-ioniceing was successful."
		else
			logHandler "Re-ioniceing was not successful."
			script_exit_code="122"
			exit
		fi
	else
		logHandler "Re-ioniceing is not enabled."
	fi
}

executePreBackupScript()
{
	local rc=

	logHandler "Check if pre backup script functionality is enabled..."

	if [ "${pre_backup_script_enabled}" -eq "1" ]
	then
		logHandler "Pre backup script functionality is enabled."
		logHandler "Check if pre backup script (${pre_backup_script}) exists and if it is executeable..."

		checkFileParameters "${pre_backup_script}"

		if [ "$(( file_permission & b_regular_file_exists ))" -gt "0" ] && [ "$(( file_permission & b_permission_execute ))" -gt "0" ]
		then
			logHandler "Pre backup script exists and it is executeable, so we execute it..."
		elif [ "$(( file_permission & b_regular_file_exists ))" -eq "0" ]
		then
			logHandler "Pre backup script doesnt exist, nothing to do."
			script_exit_code="130"
			exit
		else
			logHandler "Pre backup script exists, but it is not executeable, nothing to do."
			script_exit_code="131"
			exit
		fi

		eval "${pre_backup_script} 2>&1" | logHandler
		rc="${?}"

		if [ "${rc}" -eq "0" ]
		then
			logHandler "Execution of pre backup script was successful. rc: '${rc}'."
		else
			logHandler "Execution of pre backup script was unsuccessful. rc: '${rc}'."

			if [ "${pre_backup_exit_when_unsuccessful}" -eq "1" ]
			then
				logHandler "Breaking, because execution of pre backup script was unsuccessful und you want it."
				script_exit_code="132"
				exit
			fi
		fi
	else
		logHandler "Pre backup script functionality is not enabled."
	fi
}

checkLogDir()
{
	checkFileParameters "${script_log_directory}"

	if [ "$(( file_permission & b_is_directory ))" -gt "0" ] && [ "$(( file_permission & b_permission_read ))" -gt "0" ] && [ "$(( file_permission & b_permission_execute ))" -gt "0" ]
	then
		checkFileParameters "${script_log_file}"

		if [ "$(( file_permission & b_regular_file_exists ))" -gt "0" ] && [ "$(( file_permission & b_permission_write ))" -eq "0" ]
		then
			logHandler "Log file exists but we dont have write permissions, exiting."
			script_bypass_exit_routines="1"
			script_exit_code="10"
			exit
		else
			script_log_requirements_ok="1"
			return 0
		fi
	elif [ "$(( file_permission & b_is_directory ))" -eq "0" ]
	then
		logHandler "Log directory doesnt exist."
		logHandler "Creating log directory..."

		# shellcheck disable=SC2154
		if ${mkdir_bin} -p "${script_log_directory}" 2>&1 | logHandler
		then
			logHandler "Creating log directory was successful."
			script_log_requirements_ok="1"
		else
			logHandler "Creating log directory was not successful."
			script_bypass_exit_routines="1"
			script_exit_code="11"
			exit
		fi
	else
		logHandler "Log directory exists but permissions are not ok, exiting."
		script_bypass_exit_routines="1"
		script_exit_code="12"
		exit
	fi
}

checkBackupDirStructure()
{
	local dir=
	local dir_helper=
	local backup_dirs=("daily" "weekly" "monthly" "latest")

	logHandler "Check backup dir structure..."
	logHandler "Check if backup directory: '${backup_destination_path}' exists and permissions to move files are ok..."

	checkFileParameters "${backup_destination_path}"

	if [ "$(( file_permission & b_is_directory ))" -gt "0" ] && [ "$(( file_permission & b_permission_read ))" -gt "0" ] && [ "$(( file_permission & b_permission_execute ))" -gt "0" ]
	then
		logHandler "Backup directory exists and permissions are ok."
	elif [ "$(( file_permission & b_is_directory ))" -eq "0" ]
	then
		logHandler "Backup directory doesnt exist."
		logHandler "Creating backup directory..."

		# shellcheck disable=SC2154
		if ${mkdir_bin} -p "${backup_destination_path}" 2>&1 | logHandler
		then
			logHandler "Creating backup directory was successful."
		else
			logHandler "Creating backup directory was not successful."
			script_exit_code="140"
			exit
		fi
	else
		logHandler "Backup directory exists but permissions are not ok, exiting."
		script_exit_code="141"
		exit
	fi

	for dir in "${backup_dirs[@]}"
	do
		dir_helper="${backup_base_directory}/${dir}"

		checkFileParameters "${dir_helper}"

		if [ "$(( file_permission & b_is_directory ))" -gt "0" ] && [ "$(( file_permission & b_permission_read ))" -gt "0" ] && [ "$(( file_permission & b_permission_execute ))" -gt "0" ]
		then
			logHandler "Directory: '${dir_helper}' exist, nothing to do."
		elif [ "$(( file_permission & b_is_directory ))" -eq "0" ]
		then
			logHandler "Directory: '${dir_helper}' doesnt exist."
			logHandler "Creating directory..."

			# shellcheck disable=SC2154
			if ${mkdir_bin} -p "${dir_helper}" 2>&1 | logHandler
			then
				logHandler "Creating directory: '${dir_helper}' was successful."
			else
				logHandler "Creating directory: '${dir_helper}' was not successful."
				script_exit_code="142"
				exit
			fi
		else
			logHandler "Directory: '${dir_helper}' exists but permissions are not ok, exiting."
			script_exit_code="143"
			exit
		fi
	done
}

isInteger()
{
	local value="${1}"

	if [ "${value}" -ge "0" ] || [ "${value}" -lt "0" ] 2>/dev/null
	then
		return 0
	else
		return 1
	fi
}

bubbleSort()
{
	local array=("${@}")
	local elements="${#array[@]}"
	local i="$(( elements - 1 ))"
	local j=
	local temp_value=

	while [ "${i}" -gt "0" ]
	do
		j="0"

		while [ "${j}" -lt "${i}" ]
		do
			if [[ "${array[${j}]}" > "${array[$(( j + 1 ))]}" ]]
			then
				temp_value="${array[${j}]}"
				array[${j}]="${array[$(( j + 1 ))]}"
				array[$(( j + 1 ))]="${temp_value}"
			fi

			j="$(( j + 1 ))"
		done

		i="$(( i - 1 ))"
	done

	printf "%s\\n" "${array[@]}"
}

isLeapYear()
{
	local year="${1}"
	local month="${2}"

	if { [ "$(( year % 4 ))" -eq "0" ] && [ "$(( year % 100 ))" -ne "0" ]; } || [ "$(( year % 400))" -eq "0" ]
	then
		return 0
	else
		return 1
	fi
}

getDaysOfMonth()
{
	local year="${1}"
	local month="${2##*0}"
	local days_of_month="$(( 30 + ( month + month / 8 ) % 2 ))"

	if [ "${month}" -eq "2" ]
	then
		days_of_month="$(( days_of_month - 2 ))"

		if isLeapYear "${year}" "${month}"
		then
			days_of_month="$(( days_of_month + 1 ))"
		fi
	fi

	printf "%d" "${days_of_month}"
}

removeTodaysOldBackups()
{
	local file=
	local todays_timestamp=
	todays_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${rotation_timestamp_base_format}${date_cmd_format_suffix}")"
	local backup_files_base_name="${backup_base_directory}/${rotation_type}/${rotation_type}_${backup_base_filename}_${todays_timestamp}*.${file_extension}"
	# shellcheck disable=SC2206
	local backup_files=(${backup_files_base_name})

	logHandler "Check if old backups of type: '${rotation_type}' from today exists..."

	if [ "${#backup_files[@]}" -eq "0" ]
	then
		logHandler "No old backups of type: '${rotation_type}' from today found."
		return
	else
		for file in "${backup_files[@]}"
		do
			logHandler "Backup from today: '${file}' found..."
			logHandler "Check if permissions of file: '${file}' are ok to delete it..."

			checkFileParameters "${file}"

			if [ "$(( file_permission & b_regular_file_exists ))" -gt "0" ] && [ "$(( file_permission & b_permission_write ))" -gt "0" ]
			then
				logHandler "We have write permissions, so we can delete it."

				# shellcheck disable=SC2154
				if ${rm_bin} "${file}" 2>&1 | logHandler
				then
					logHandler "Deleting file was successful."
				else
					logHandler "Deleting file was not successful."
					script_exit_code="150"
					exit
				fi
			elif [ "$(( file_permission & b_regular_file_exists ))" -eq "0" ]
			then
				logHandler "File doenst exist, nothing to do."
			else
				logHandler "We dont have write permissions, nothing to do."
			fi
		done
	fi
}

removeOldBackups()
{
	local file=
	local backup_files_base_name="${backup_base_directory}/${rotation_type}/${rotation_type}_${backup_base_filename}_"
	# shellcheck disable=SC2206
	local backup_files=(${backup_files_base_name}*.${file_extension})
	# shellcheck disable=SC2207
	local backup_files_sorted=($(bubbleSort "${backup_files[@]}"))
	local backup_files_count="${#backup_files[@]}"
	local backups_to_delete_counter=

	logHandler "Check if rotation of ${rotation_type} backups is necessary..."

	case "${rotation_type}" in
		daily)
			if [ "${backup_files_count}" -gt "${backup_rotation_daily_max_backups}" ]
			then
				backups_to_delete_counter="$(( backup_files_count - backup_rotation_daily_max_backups ))"
				logHandler "Rotation of ${rotation_type} backups is necessary (backup_files_count: '${backup_files_count}' > backup_rotation_daily_max_backups: '${backup_rotation_daily_max_backups}')."
			else
				logHandler "Rotation of ${rotation_type} backups is not necessary (backup_files_count: '${backup_files_count}' <= backup_rotation_daily_max_backups: '${backup_rotation_daily_max_backups}')."
				return
			fi
			;;
		weekly)
			if [ "${backup_files_count}" -gt "${backup_rotation_weekly_max_backups}" ]
			then
				backups_to_delete_counter="$(( backup_files_count - backup_rotation_weekly_max_backups ))"
				logHandler "Rotation of ${rotation_type} backups is necessary (backup_files_count: '${backup_files_count}' > backup_rotation_weekly_max_backups: '${backup_rotation_weekly_max_backups}')."
			else
				logHandler "Rotation of ${rotation_type} backups is not necessary (backup_files_count: '${backup_files_count}' <= backup_rotation_weekly_max_backups: '${backup_rotation_weekly_max_backups}')."
				return
			fi
			;;
		monthly)
			if [ "${backup_files_count}" -gt "${backup_rotation_monthly_max_backups}" ]
			then
				backups_to_delete_counter="$(( backup_files_count - backup_rotation_monthly_max_backups ))"
				logHandler "Rotation of ${rotation_type} backups is necessary (backup_files_count: '${backup_files_count}' > backup_rotation_monthly_max_backups: '${backup_rotation_monthly_max_backups}')."
			else
				logHandler "Rotation of ${rotation_type} backups is not necessary (backup_files_count: '${backup_files_count}' <= backup_rotation_monthly_max_backups: '${backup_rotation_monthly_max_backups}')."
				return
			fi
			;;
	esac

	if [ -n "${backups_to_delete_counter}" ]
	then
		for file in "${backup_files_sorted[@]}"
		do
			if [ "${backups_to_delete_counter}" -gt "0" ]
			then
				logHandler "Backup to delete: '${file}' found..."
				logHandler "Check if permissions of file: '${file}' are ok to delete it..."

				checkFileParameters "${file}"

				if [ "$(( file_permission & b_regular_file_exists ))" -gt "0" ] && [ "$(( file_permission & b_permission_write ))" -gt "0" ]
				then
					logHandler "We have write permissions, so we can delete it."

					# shellcheck disable=SC2154
					if ${rm_bin} "${file}" 2>&1 | logHandler
					then
						logHandler "Deleting file was successful."
					else
						logHandler "Deleting file was not successful."
						script_exit_code="160"
						exit
					fi
				elif [ "$(( file_permission & b_regular_file_exists ))" -eq "0" ]
				then
					logHandler "File doenst exist, nothing to do."
				else
					logHandler "We dont have write permissions, nothing to do."
				fi

				backups_to_delete_counter="$(( backups_to_delete_counter - 1 ))"
			fi
		done
	fi
}

rotateHandler()
{
	local file=
	local file_new=
	local actual_weekday=
	local actual_weekday_format="%u"
	local actual_day_of_month=
	local actual_day_of_month_format="%-d"
	local actual_month=
	local actual_month_format="%m"
	local actual_year=
	local actual_year_format="%Y"
	local last_day_of_month=
	local rotation_timestamp=
	local rotation_types=("daily" "weekly" "monthly")
	local rotation_daily_timestamp_format="${rotation_timestamp_base_format}_%Hh%Mm_%A"
	local rotation_weekly_timestamp_format="${rotation_timestamp_base_format}_%Hh%Mm_%W"
	local rotation_monthly_timestamp_format="${rotation_timestamp_base_format}_%Hh%Mm_%B"

	logHandler "Check if backup rotation is enabled..."

	if [ "${backup_rotation_daily_enabled}" -eq "1" ] || [ "${backup_rotation_weekly_enabled}" -eq "1" ] || [ "${backup_rotation_monthly_enabled}" -eq "1" ]
	then
		logHandler "Backup rotation is enabled."
		logHandler "Check if only one backup per day is enabled..."

		if [ "${backup_rotation_one_backup_per_day_only}" -eq "1" ]
		then
			logHandler "Only one backup per day is enabled."
		else
			logHandler "Only one backup per day is not enabled."
		fi

		if [ "${backup_encryption_enabled}" -eq "1" ]
		then
			file="${backup_encryption_filename}"
		else
			file="${backup_filename}"
		fi

		for rotation_type in "${rotation_types[@]}"
		do
			case "${rotation_type}" in
				daily)
					if [ "${backup_rotation_daily_enabled}" -eq "1" ]
					then
						rotation_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${rotation_daily_timestamp_format}${date_cmd_format_suffix}")"

						if [ "${backup_rotation_one_backup_per_day_only}" -eq "1" ]
						then
							removeTodaysOldBackups
						fi

						file_new="${rotation_type}_${backup_base_filename}_${rotation_timestamp}.${file_extension}"

						logHandler "Copying actual backup: '${file}' ==> '${backup_base_directory}/${rotation_type}/${file_new}'."

						# shellcheck disable=SC2154
						if ${cp_bin} -a "${file}" "${backup_base_directory}/${rotation_type}/${file_new}" 2>&1 | logHandler
						then
							logHandler "Copy job was successful."
						else
							logHandler "Copy job was not successful."
							script_exit_code="170"
							exit
						fi
					fi
					;;
				weekly)
					if [ "${backup_rotation_weekly_enabled}" -eq "1" ]
					then
						logHandler "Check if today is the day, where ${rotation_type} backups should be rotated..."
						actual_weekday="$(eval "${date_bin} ${date_cmd_format_prefix}${actual_weekday_format}${date_cmd_format_suffix}")"

						if [ "${actual_weekday}" -eq "${backup_rotation_weekly_weekday}" ]
						then
							logHandler "Today is the day, where we should rotate the ${rotation_type} backups (actual_weekday: '${actual_weekday}' == backup_rotation_weekly_weekday: '${backup_rotation_weekly_weekday}')."

							rotation_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${rotation_weekly_timestamp_format}${date_cmd_format_suffix}")"

							if [ "${backup_rotation_one_backup_per_day_only}" -eq "1" ]
							then
								removeTodaysOldBackups
							fi

							file_new="${rotation_type}_${backup_base_filename}_${rotation_timestamp}.${file_extension}"

							logHandler "Copying actual backup: '${file}' ==> '${backup_base_directory}/${rotation_type}/${file_new}'."

							# shellcheck disable=SC2154
							if ${cp_bin} -a "${file}" "${backup_base_directory}/${rotation_type}/${file_new}" 2>&1 | logHandler
							then
								logHandler "Copy job was successful."
							else
								logHandler "Copy job was not successful."
								script_exit_code="171"
								exit
							fi
						else
							logHandler "Today is not the day, where we should rotate the ${rotation_type} backups (actual_weekday: '${actual_weekday}' != backup_rotation_weekly_weekday: '${backup_rotation_weekly_weekday}')."
							continue
						fi
					fi
					;;
				monthly)
					if [ "${backup_rotation_monthly_enabled}" -eq "1" ]
					then
						logHandler "Check if today is the day, where ${rotation_type} backups should be rotated..."
						actual_day_of_month="$(eval "${date_bin} ${date_cmd_format_prefix}${actual_day_of_month_format}${date_cmd_format_suffix}")"
						actual_month="$(eval "${date_bin} ${date_cmd_format_prefix}${actual_month_format}${date_cmd_format_suffix}")"
						actual_year="$(eval "${date_bin} ${date_cmd_format_prefix}${actual_year_format}${date_cmd_format_suffix}")"
						last_day_of_month="$(getDaysOfMonth "${actual_year}" "${actual_month}")"

						if [ "${actual_day_of_month}" -eq "${backup_rotation_monthly_day_of_month}" ] || { [ "${backup_rotation_monthly_day_of_month}" -ge "28" ] && [ "${actual_day_of_month}" -eq "${last_day_of_month}" ]; }
						then
							if [ "${actual_day_of_month}" -eq "${backup_rotation_monthly_day_of_month}" ]
							then
								logHandler "Today is the day, where we should rotate the ${rotation_type} backups (actual_day_of_month: '${actual_day_of_month}' == backup_rotation_monthly_day_of_month: '${backup_rotation_monthly_day_of_month}')."
							elif [ "${actual_day_of_month}" -eq "${last_day_of_month}" ]
							then
								logHandler "Today is not the day, where we should rotate the ${rotation_type} backups, but it is the last day of month, so we prepone the rotation (actual_day_of_month: '${actual_day_of_month}' == last_day_of_month: '${last_day_of_month}')."
							fi

							rotation_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${rotation_monthly_timestamp_format}${date_cmd_format_suffix}")"

							if [ "${backup_rotation_one_backup_per_day_only}" -eq "1" ]
							then
								removeTodaysOldBackups
							fi

							file_new="${rotation_type}_${backup_base_filename}_${rotation_timestamp}.${file_extension}"

							logHandler "Copying actual backup: '${file}' ==> '${backup_base_directory}/${rotation_type}/${file_new}'."

							# shellcheck disable=SC2154
							if ${cp_bin} -a "${file}" "${backup_base_directory}/${rotation_type}/${file_new}" 2>&1 | logHandler
							then
								logHandler "Copy job was successful."
							else
								logHandler "Copy job was not successful."
								script_exit_code="172"
								exit
							fi
						else
							logHandler "Today is not the day, where we should rotate the ${rotation_type} backups (actual_day_of_month: '${actual_day_of_month}' != backup_rotation_monthly_day_of_month: '${backup_rotation_monthly_day_of_month}')."
							continue
						fi
					fi
					;;
			esac

			removeOldBackups
		done
	else
		logHandler "Backup rotation is not enabled."
	fi
}

createInstalledPackagesFile()
{
	local syspackage_manager=
	local available_syspackage_managers_helper=
	local create_installed_packages_cmd=

	logHandler "Check if installed packages are enabled..."

	if [ "${installed_packages_enabled}" -eq "1" ]
	then
		logHandler "Installed packages are enabled."

		if [ "${#available_syspackage_managers[@]}" -gt "1" ]
		then
			available_syspackage_managers_helper="${available_syspackage_managers[*]}"
			available_syspackage_managers_helper="${available_syspackage_managers_helper//\ /\,\ }"

			logHandler "More than one supported syspackage managers found: '${available_syspackage_managers_helper}', dont know what to do, exiting."

			if [ -z "${installed_packages_forced_manager}" ]
			then
				logHandler "HINT: You can force to use one of the supported syspackage managers by setting configuration variable: 'installed_packages_forced_manager'."
			fi

			script_exit_code="180"
			exit
		elif [ "${#available_syspackage_managers[@]}" -eq "1" ]
		then
			syspackage_manager="${available_syspackage_managers[*]}"
			logHandler "The supported system package manager we found is: '${syspackage_manager}'."
		elif [ "${#available_syspackage_managers[@]}" -eq "0" ]
		then
			logHandler "No supported system package manager found, exiting."
			script_exit_code="181"
			exit
		fi

		logHandler "Creating installed packages file: '${installed_packages_filename}'..."

		case "${syspackage_manager}" in
			rpm)
				create_installed_packages_cmd="${syspackage_manager} --query --all >${installed_packages_filename}"
				;;
			dpkg)
				create_installed_packages_cmd="${syspackage_manager} --list >${installed_packages_filename}"
				;;
			pacman)
				create_installed_packages_cmd="${syspackage_manager} --query --explicit >${installed_packages_filename}"
				;;
			equery)
				create_installed_packages_cmd="${syspackage_manager} list \"*\" >${installed_packages_filename}"
				;;
			pkgutil)
				create_installed_packages_cmd="${syspackage_manager} --pkgs >${installed_packages_filename}"
				;;
			*)
				logHandler "Unsupported syspackage manager used in function: '${FUNCNAME[0]}'. :( Exiting."
				script_exit_code="182"
				exit
				;;
		esac

		if eval "${create_installed_packages_cmd}" 2>&1 >/dev/null | logHandler
		then
			logHandler "Creating installed packages file was successful, adding file to backup_items config array."
			backup_items+=("${installed_packages_filename}")
		else
			logHandler "Creating installed packages file was not successful."
			script_exit_code="183"
			exit
		fi
	else
		logHandler "Installed packages are not enabled..."
	fi
}

buildExcludeOpts()
{
	local item=

	logHandler "Check if we need to build excluding options..."

	if [ -n "${backup_exlude_items[*]:-}" ]
	then
		logHandler "Building of excluding options is enabled."
		exclude_string=()

		for item in "${backup_exlude_items[@]}"
		do
			exclude_string+=("--exclude=${item}")
		done

		logHandler "We build the following excluding options: '${exclude_string[*]}'."
	else
		logHandler "We dont have to build excluding options..."
	fi
}

buildBackupCmd()
{
	logHandler "Building backup command..."

	backup_options=("--create")

	if [ "${backup_compression_enabled}" -eq "1" ]
	then
		case "${backup_compression_type}" in
			gzip)
				backup_options+=("--gzip")
				;;
			bzip2)
				backup_options+=("--bzip2")
				;;
			xz)
				backup_options+=("--xz")
				;;
			lzip)
				backup_options+=("--lzip")
				;;
			lzma)
				backup_options+=("--lzma")
				;;
			lzop)
				backup_options+=("--lzop")
				;;
			*)
				logHandler "Unsupported compression type configured, exiting."
				script_exit_code="190"
				exit
				;;
		esac
	fi

	backup_options+=("--file=${backup_filename}")

	if [ "${backup_verbose_mode_enabled}" -eq "1" ]
	then
		backup_options+=("--verbose")
	fi

	if [ "${backup_show_totals}" -eq "1" ]
	then
		backup_options+=("--totals")
	fi

	if [ -n "${backup_individual_options[*]}" ]
	then
		backup_options+=("${backup_individual_options[@]}")
	fi

	if [ -z "${exclude_string[*]:-}" ]
	then
		# shellcheck disable=SC2154
		backup_cmd="${tar_bin} ${backup_options[*]} ${backup_items[*]}"
	else
		# shellcheck disable=SC2154
		backup_cmd="${tar_bin} ${exclude_string[*]} ${backup_options[*]} ${backup_items[*]}"
	fi

	logHandler "We build the following backup command: '${backup_cmd}'."
}

makeBackup()
{
	local rc=

	logHandler "Starting backup job..."

	if ${backup_cmd} 2>&1 | logHandler
	then
		logHandler "Backup job was successful. (tar return value: '0' <= backup_successful_tar_rc: '${backup_successful_tar_rc}')"
		backup_successful="1"
	else
		rc="${?}"

		if [ "${rc}" -le "${backup_successful_tar_rc}" ]
		then
			logHandler "Backup job was successful. (tar return value: '${rc}' <= backup_successful_tar_rc: '${backup_successful_tar_rc}')"
			backup_successful="1"
		else
			logHandler "Backup job was not successful. (tar return value: '${rc}' > backup_successful_tar_rc: '${backup_successful_tar_rc}')"
			script_exit_code="200"
			exit
		fi
	fi
}

encryptBackup()
{
	if [ "${backup_encryption_enabled}" -eq "1" ]
	then
		logHandler "Backup encryption is enabled..."
		logHandler "Encrypting backup file: '${backup_filename}'..."

		# shellcheck disable=SC2154
		if ${openssl_bin} aes-256-cbc -salt -in "${backup_filename}" -out "${backup_encryption_filename}" -k "${backup_encryption_password}" 2>&1 | logHandler
		then
			logHandler "Encrypting job was successful."
			logHandler "HINT: To decrypt use this command: '${openssl_bin} aes-256-cbc -d -salt -in ${backup_encryption_filename} -out ${backup_filename}'."
			encryption_successful="1"
		else
			logHandler "Encrypting job was not successful."
			script_exit_code="210"
			exit
		fi
	else
		logHandler "Backup encryption is not enabled..."
	fi
}

executePostBackupScript()
{
	local rc=

	logHandler "Check if post backup script functionality is enabled..."

	if [ "${post_backup_script_enabled}" -eq "1" ]
	then
		logHandler "Post backup script functionality is enabled."
		logHandler "Check if post backup script (${post_backup_script}) exists and if it is executeable..."

		checkFileParameters "${post_backup_script}"

		if [ "$(( file_permission & b_regular_file_exists ))" -gt "0" ] && [ "$(( file_permission & b_permission_execute ))" -gt "0" ]
		then
			logHandler "Post backup script exists and it is executeable, so we execute it..."
		elif [ "$(( file_permission & b_regular_file_exists ))" -eq "0" ]
		then
			logHandler "Post backup script doesnt exist, nothing to do."
			script_exit_code="230"
			exit
		else
			logHandler "Post backup script exists, but it is not executeable, nothing to do."
			script_exit_code="231"
			exit
		fi

		eval "${post_backup_script} 2>&1" | logHandler
		rc="${?}"

		if [ "${rc}" -eq "0" ]
		then
			logHandler "Execution of post backup script was successful. rc: '${rc}'."
		else
			logHandler "Execution of post backup script was unsuccessful. rc: '${rc}'."

			if [ "${post_backup_exit_when_unsuccessful}" -eq "1" ]
			then
				logHandler "Breaking, because execution of post backup script was unsuccessful und you want it."
				script_exit_code="232"
				exit
			fi
		fi
	else
		logHandler "Post backup script functionality is not enabled."
	fi
}

_main()
{
	checkCliOptions
	setDefaultConfig
	setRequiredVariables
	includeConfig
	setConfigurationVariables
	checkRequiredBinaries
	logHandlerSetConfig
	checkLogHandlerRequirements
	checkRootPrivileges
	getUser
	checkBashVersion
	checkAlreadyRunningInstance
	reNice
	reIONice
	checkBackupDirStructure
	executePreBackupScript
	createInstalledPackagesFile
	buildExcludeOpts
	buildBackupCmd
	makeBackup
	encryptBackup
	executePostBackupScript
}



#-------
# Start:
#-------

#-----------------------
# Script info variables:
#-----------------------

script_pid="${BASHPID}"
script_name="${0##*/}"
script_version="2.0.0-beta4"
script_author="Christian Zettel (ccztux)"
script_copyright="Copyright Â© 2017 ${script_author}, all rights reserved"
script_project_website="https://github.com/ccztux/glsysbackup"
script_last_modification_date="2019-11-17"
script_minimal_required_bash_version="3"
script_license="GNU GPLv3"
script_description="${script_name} (Generic Linux System Backup) is an advanced backup tool written in bash."
script_exit_code="255"
script_another_instance_is_running="0"
script_bypass_exit_routines="0"
script_shutdown_in_progress="0"
script_log_file_truncated="0"
script_config_file_included="0"
script_log_requirements_ok="0"



if [ "${BASH_SOURCE[0]}" == "${0}" ]
then
	#-------------------------------------
	# Set required bash and shell options:
	#-------------------------------------

	setRequiredShellOptions
	setRequiredBashOptions



	#-----------------
	# Get CLI options:
	#-----------------

	OPTERR="0"

	while getopts ":c:hv" OPTION
	do
		case "${OPTION}" in
			c)
				script_config_file="${OPTARG}"
				;;
			h)
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="240"
				exit
				;;
			v)
				printScriptInfos
				script_bypass_exit_routines="1"
				script_exit_code="241"
				exit
				;;
			\?)
				logHandler "Invalid option: -${OPTARG}\\n"
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="242"
				exit
				;;
			:)
				logHandler "Option: -${OPTARG} requires an argument.\\n"
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="243"
				exit
				;;
		esac
	done



	#-----------------------------------------------------
	# In case of direct execution jump into main function:
	#-----------------------------------------------------

	_main "${@}"
	exit
else
	#--------------------------------------------------------
	# In case of an include attempt, write output and return:
	#--------------------------------------------------------

	trap - ERR
	logHandler "\\n${BASH_SOURCE[0]##*/} is NOT a bash library. Execute it directly!\\n"
	return 1
fi
